2. Data Types
   2.1 Primitive Data Types
      2.1.1 Integer
        signed char
		 The 8-bit signed char data type can hold integer values in the range of -128 to 127.
    	unsigned char
    		The 8-bit unsigned char data type can hold integer values in the range of 0 to 255.
    	char
    		The 16-bit short int data type can hold integer values in the range of -32,768 to 32,767. You may also refer to this data type as short, signed short int, or signed short.
    	unsigned short int
    		The 16-bit unsigned short int data type can hold integer values in the range of 0 to 65,535. You may also refer to this data type as unsigned short.
    	int
    		The 32-bit int data type can hold integer values in the range of -2,147,483,648 to 2,147,483,647. You may also refer to this data type as signed int or signed.
    	unsigned int
    		The 32-bit unsigned int data type can hold integer values in the range of 0 to 4,294,967,295. You may also refer to this data type simply as unsigned.
    	long int
    		The 32-bit long int data type can hold integer values in the range of at least -2,147,483,648 to 2,147,483,647. (Depending on your system, this data type might be 64-bit, in which case its range is identical to that of the long long int data type.) You may also refer to this data type as long, signed long int, or signed long.
    	unsigned long int
    		The 32-bit unsigned long int data type can hold integer values in the range of at least 0 to 4,294,967,295. (Depending on your system, this data type might be 64-bit, in which case its range is identical to that of the unsigned long long int data type.) You may also refer to this data type as unsigned long.
    	long long int
    		The 64-bit long long int data type can hold integer values in the range of -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. You may also refer to this data type as long long, signed long long int or signed long long. This type is not part of C89, but is both part of C99 and a GNU C extension.
    	unsigned long long int
    		The 64-bit unsigned long long int data type can hold integer values in the range of at least 0 to 18,446,744,073,709,551,615. You may also refer to this data type as unsigned long long. This type is not part of C89, but is both part of C99 and a GNU C extension. 

      2.1.2 Float
         Example: float
         Usage: Typically used for real numbers with decimal points.

      2.1.3 Double
         Example: double
         Usage: Offers higher precision for floating-point calculations.

   2.2 Enumeration
      2.2.1 Declaring Enumeration
         //enumerations are defined using the keyword enum followed by the name of the enum (optional)
         //followed by a list of constant names seperated by commas and enclosed in braces ending with a semicolon
         enum week{Monday, Tuesday, Wednesday, Thursday, Friday, Saturday};
         // by default the first value is 0, the values are incremented by 1 after that 
         // one or more values can be declared explicitly
         enum week{Monday = 1, Tuesday, Wednesday, Thursday, Friday, Saturday};
         //in this example Monday is declared as 1 and the values of following declarations will be incremented by 1. 
         //(Tuesday = 2, Wednesday = 3...)

   2.3 Structures

   2.4 Arrays

   2.5 Pointers
      2.5.1 Declaring Pointers
         Pointers are used to store memory addresses. They can point to data of various types, including integers, floats, structures, and more.

         Example:
         int *intPtr;         // Pointer to an integer
         float *floatPtr;     // Pointer to a float
         struct Person *personPtr;  // Pointer to a structure of type Person

      2.5.2 Initializing Pointers
         Pointers should be initialized with the address of a valid variable or memory location.

         Example:
         int x = 42;
         int *ptr = &x;  // Initializes ptr with the address of integer variable x

      2.5.3 Dereferencing Pointers
         To access the value pointed to by a pointer, you can use the dereference operator (*).

         Example:
         int y = *ptr;  // Assigns the value at the address pointed to by ptr to y

      2.5.4 Pointer Arithmetic
         Pointers can be manipulated using arithmetic operations. These operations allow you to navigate through arrays and memory blocks.

         Example:
         int numbers[5] = {1, 2, 3, 4, 5};
         int *ptr = numbers;  // Initialize ptr with the address of the first element

         // Access elements using pointer arithmetic
         int thirdElement = *(ptr + 2);  // thirdElement will be 3

   2.6 Incomplete Types

   2.7 Type Qualifiers

   2.8 Type Specifiers

3. Functions
   3.1 Serial Communication Functions
      3.1.1 `serial_init(device dev)`
         // Initializes the serial communication for a specified device.
         Parameters:
         - `device dev`: The device identifier (e.g., COM1, COM2).
         Return Value:
         Returns 0 on success, -1 on failure.
         Usage:
         Call this function to initialize serial communication for a specific device.
         It configures various settings, such as baud rate, data format, and interrupts.

      3.1.2 `serial_out(device dev, const char *buffer, size_t len)`
         // Sends data over the specified serial device.
         Parameters:
         - `device dev`: The device identifier (e.g., COM1, COM2).
         - `const char *buffer`: Pointer to the data to be sent.
         - `size_t len`: The length of the data to be sent.
         Return Value:
         Returns the number of bytes sent or -1 on failure.
         Usage:
         Use this function to send data over the serial device. It sends the provided data buffer of
         a specified length.

      3.1.3 `serial_poll(device dev, char *buffer, size_t len)`
         // Polls the serial device for input and collects characters into a buffer.
         Parameters:
         - `device dev`: The device identifier (e.g., COM1, COM2).
         - `char *buffer`: Pointer to the buffer where received characters are stored.
         - `size_t len`: The maximum number of characters to read.
         Return Value:
         Returns the number of characters read and stored in the buffer.
         Usage:
         This function continuously polls the serial device for incoming characters.
         It collects characters into the provided buffer until the buffer is full or a special
         condition (e.g., Enter key) is met.

4. Source Files
   4.1 `serial.c`
      // This source file contains functions and configurations related to serial communication.

   4.2 `comhand.c`
      // This source file defines the `comhand` function, which serves as a command-line interface for the
      // operating system. Users can interact with the system through this interface.

   4.3 `dateandtime.c`
      // This source file provides functions for reading and setting the system date and time. It communicates
      // with the real-time clock (RTC) hardware to retrieve and update date and time information.

5. Enumeration
   5.1 `uart_registers`
      // This enumeration defines constants representing UART (Universal Asynchronous Receiver/Transmitter)
      // registers used for serial communication configuration.

6. Dependencies
   - `mpx/io.h`: This header file provides I/O operations for communication with hardware devices.
   - `mpx/serial.h`: This header file includes declarations related to serial communication.
   - `sys_req.h`: This header file contains system request related definitions.
   - `string.h`: This header file provides string manipulation functions.
   - `stdbool.h`: This header file defines the boolean data type.
   - `dateAndTime.h`: This header file includes declarations related to date and time functions.
   - `stdlib.h`: This header file provides standard library functions.
   - `mpx/interrupts.h`: This header file contains interrupt-related definitions.
